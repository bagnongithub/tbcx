.TH tbcx 3 "Oct 22, 2025" "tbcx 1.0" "Tcl Bytecode eXchange"
.SH NAME
tbcx \- serialize, load, and inspect precompiled Tcl 9.1 bytecode (procs, OO methods, and lambdas)
.SH SYNOPSIS
.nf
\fBtbcx::save\fR \fIin out\fR
\fBtbcx::load\fR \fIin\fR
\fBtbcx::dump\fR \fIfilename\fR
.fi

.SH DESCRIPTION
The \fBtbcx\fR extension provides three subcommands that enable an efficient
\fIsave \[->] load \[->] eval\fR pipeline for Tcl 9.1 scripts. The goal is to pay the cost of
parsing/compiling at save time so that loading is as fast as reading a compact binary, while
remaining functionally equivalent to \fBsource\fR of the original script.
.PP
Artifacts store the compiled top\-level, precompiled \fBproc\fR bodies, TclOO method/ctor/dtor
bodies, and \fBlambda\fR literals for use with \fBapply\fR. Loading installs these into the current
interpreter and executes the top\-level block in the caller's current namespace.

.SH COMMANDS
.SS "tbcx::save in out"
.B Synopsis
.PP
Compile a script and write a \fB.tbcx\fR artifact.
.PP
.B Parameters
.TP
.I in
One of:
.RS
.IP \(bu 2
\fIString\fR \- a Tcl string value containing the script text.
.IP \(bu 2
\fIReadable channel\fR \- an open channel; the command enforces binary\-safe reads.
.IP \(bu 2
\fIReadable path\fR \- a filesystem path to a script file; it is opened, read, and closed by \fBtbcx::save\fR.
.RE
.TP
.I out
One of:
.RS
.IP \(bu 2
\fIWritable channel\fR \- an open channel; the command writes binary data and does \fInot\fR close the channel.
.IP \(bu 2
\fIWritable path\fR \- a filesystem path for the new \fB.tbcx\fR file; it is created/truncated and closed on return.
.RE
.PP
.B Behavior
.RS
.IP \(bu 2
Compiles the top\-level block, discovers and precompiles \fBproc\fR bodies and TclOO method/ctor/dtor bodies,
and captures \fIlambda literals\fR as lambda\-bytecode literals (for \fBapply\fR).
.IP \(bu 2
Serializes the header, top\-level block, Procs table, Classes catalog (advisory), and Methods table.
.RE
.PP
.B Returns
.RS
The output object: either the normalized path written, or the writable channel handle.
.RE
.PP
.B Errors
.RS
Typical errors include: unreadable input; unwritable output; version/format mismatch; unknown/unsupported AuxData;
size limit exceeded (code, literals, AuxData, exception ranges, strings); short read/write.
The interpreter result contains a descriptive message.
.RE
.PP
.B Notes
.RS
.IP \(bu 2
Channels are treated as binary for portability; encodings are not altered on the caller's behalf, and channels are not closed.
.IP \(bu 2
The produced artifact is intended for Tcl 9.1; other versions are rejected at load time.
.RE
.PP
.B Examples
.nf
# Save from path \-> path
set path [tbcx::save ./app.tcl ./app.tbcx]

# Save from string value \-> path
set script {proc hi {} {puts Hello}; hi}
tbcx::save $script ./hello.tbcx

# Save from channel \-> channel
set in  [open ./lib/foo.tcl r]
set out [open ./foo.tbcx w]
fconfigure $in  -translation binary -eofchar {}
fconfigure $out -translation binary -eofchar {}
try {
    tbcx::save $in $out
} finally {
    close $in
    close $out
}
.fi

.SS "tbcx::load in"
.B Synopsis
.PP
Load a \fB.tbcx\fR artifact, install precompiled entities, and execute the top\-level block.
.PP
.B Parameters
.TP
.I in
One of:
.RS
.IP \(bu 2
\fIReadable channel\fR \- an open channel positioned at the beginning of a \fB.tbcx\fR stream (binary).
.IP \(bu 2
\fIReadable path\fR \- a filesystem path to a \fB.tbcx\fR file.
.RE
.PP
.B Behavior
.RS
.IP \(bu 2
Validates header and producer version; deserializes sections.
.IP \(bu 2
Materializes procs and TclOO methods (ctors/dtors) from precompiled bodies.
.IP \(bu 2
Rehydrates lambda\-bytecode literals so the first \fBapply\fR incurs no compilation.
.IP \(bu 2
Executes the precompiled top\-level block in the caller's current namespace.
.RE
.PP
.B Returns
.RS
Empty string on success.
.RE
.PP
.B Errors
.RS
Typical errors include: unreadable input; bad header; incompatible Tcl version; malformed/unknown section;
size limit exceeded; short read; class or namespace creation errors during top\-level evaluation.
.RE
.PP
.B Notes
.RS
.IP \(bu 2
Load in a specific namespace by wrapping the call: \fBnamespace eval ::pkg { tbcx::load ./app.tbcx }\fR
.IP \(bu 2
Loading executes code; only load artifacts from trusted sources.
.RE
.PP
.B Examples
.nf
# Load into current namespace
tbcx::load ./app.tbcx

# Load into a dedicated namespace
namespace eval ::app { tbcx::load ./app.tbcx }

# Load from an open channel
set ch [open ./app.tbcx r]
fconfigure $ch -translation binary -eofchar {}
try {
    tbcx::load $ch
} finally {
    close $ch
}
.fi

.SS "tbcx::dump filename"
.B Synopsis
.PP
Disassemble and describe a \fB.tbcx\fR artifact in human\-readable form.
.PP
.B Parameters
.TP
.I filename
A readable path to a \fB.tbcx\fR file.
.PP
.B Behavior
.RS
Reads the artifact and prints: header fields; section summaries; literals and AuxData; exception ranges;
and a disassembly of the top\-level, proc, method, and lambda bodies.
.RE
.PP
.B Returns
.RS
A string containing the formatted dump.
.RE
.PP
.B Errors
.RS
Unreadable file; bad header; malformed section; short read.
.RE
.PP
.B Examples
.nf
% package require tbcx
% tbcx::save {set a 1} out
% tbcx::dump out
TBCX Header:
  magic = 0x58434254 ('T''B''C''X')
  format = 9
  tcl_version = 9.1.0 (type 0)
  top: code=12, except=0, lits=2, aux=0, locals=1, stack=2

Top-level block:
  Disassembly (top-level):
ByteCode 0x7f9963089e10, refCt 1, epoch 20, interp 0x7f9963816a10 (epoch 20)
  Source ""
  Cmds 0, src 0, inst 11, litObjs 1, aux 0, stkDepth 1, code/src 0.00
    (0) push 0 	# "1"
    (5) storeScalar %v0
    (10) done

  code=11, stack=1, lits=1, aux=0, except=0
  Locals (1):
    [0] "a"
  Literals:
    [0] (bignum) 1

Procs: 0

Classes: 0

Methods: 0
.fi

.SH FILE FORMAT (OVERVIEW)
.PP
This section summarizes the on\-disk structure.
.TP
.B Header
Magic + format version + producing Tcl version; size/count metadata for the top\-level block
(code length, literal count, AuxData count, exception ranges, locals, max stack).
.TP
.B Sections (order)
(1) Top\-level block (code, literals, AuxData, exceptions, locals epilogue);
(2) Procs (FQN, ns, arg spec, compiled block);
(3) Classes (advisory catalog; actual creation occurs at load time);
(4) Methods (class, kind, name, args, compiled block).
.TP
.B Literal kinds
boolean, (wide)int/uint, double, bignum, string, bytearray, list, dict, embedded bytecode,
and \fBlambda\-bytecode\fR literals for use with \fBapply\fR.
.TP
.B AuxData families
jump tables (string or numeric), dictupdate, foreach (legacy/new).

.SH LAMBDA SUPPORT
.PP
Literals in the script that represent \fIlambdas\fR for \fBapply\fR (lists of the form
\fC{args body ?ns?}\fR) are compiled and serialized as lambda\-bytecode literals at save time.
On load, both the compiled body and the optional namespace element are rehydrated so that the
first call to \fBapply\fR does not trigger compilation.

.SH SEMANTICS AND PERFORMANCE
.PP
Artifacts are portable across little\- and big\-endian hosts. The loader detects host byte order
once and applies a tight in\-place swap over bulk sections that require conversion, avoiding
per\-field branching so cross\-endian loads remain close to native performance.
.PP
Loading executes the precompiled top\-level, then installs precompiled proc/method bodies and
rehydrates lambda literals. The intent is to be functionally indistinguishable from \fBsource\fR
of the original script, with the benefit of faster startup due to avoided parsing/compilation.

.SH LIMITS
.PP
Sanity caps exist for code size, literal count (including lambdas), AuxData count, exception ranges,
and string lengths. Exceeding limits produces an error.

.SH DIAGNOSTICS
.PP
Representative messages include: "bad header", "incompatible Tcl version", "short read/write",
"unsupported AuxData kind", "input is neither an open channel nor a readable file", and
"errors while evaluating top\-level".

.SH SECURITY
.PP
Loading executes code. Only load artifacts you trust.

.SH SEE ALSO
source(n), TclOO(n)

.SH COPYRIGHT
\[co] 2025 Miguel Banon

MIT License.
