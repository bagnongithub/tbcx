# -*-Tcl-*-

package require tbcx
package require tcltest 2.5
namespace import ::tcltest::*

# --- Literals ---------------------------------------------------------------

test test_literal.1 {LIT: STRING} -body {
    set in  [makeFile {return "hello"} test_literal.1-in.tcl]
    set out [makeFile "" test_literal.1-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result hello

test test_literal.2 {LIT: BOOLEAN (true/false)} -body {
    set in  [makeFile {return [list [expr {true || true}] [expr {false && false}]]} test_literal.2-in.tcl]
    set out [makeFile "" test_literal.2-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result {1 0}

test test_literal.3 {LIT: WIDEINT (signed 64)} -body {
    set in  [makeFile {return 9223372036854775807} test_literal.3-in.tcl]
    set out [makeFile "" test_literal.3-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 9223372036854775807

test test_literal.4 {LIT: UWIDEINT (unsigned 64)} -body {
    set in  [makeFile {return 18446744073709551615} test_literal.4-in.tcl]
    set out [makeFile "" test_literal.4-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 18446744073709551615

test test_literal.5 {LIT: BIGNUM (positive bignum)} -body {
    set in  [makeFile {return 18446744073709551616} test_literal.5-in.tcl]
    set out [makeFile "" test_literal.5-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 18446744073709551616

test test_literal.6 {LIT: BIGNUM (negative bignum)} -body {
    set in  [makeFile {return -9223372036854775809} test_literal.6-in.tcl]
    set out [makeFile "" test_literal.6-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result -9223372036854775809

test test_literal.7 {LIT: DOUBLE} -body {
    set in  [makeFile {return 3.14} test_literal7-in.tcl]
    set out [makeFile "" test_literal.7-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 3.14

test test_literal.8 {LIT: LIST} -body {
    set in  [makeFile {set L [list a 1 b 2]; return $L} test_literal8-in.tcl]
    set out [makeFile "" test_literal.8-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result {a 1 b 2}

test test_literal.9 {LIT: DICT} -body {
    set in  [makeFile {return [dict create a 1 b 2]} test_literal9-in.tcl]
    set out [makeFile "" test_literal.9-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result {a 1 b 2}

test test_literal.10 {LIT: BYTEARRAY} -body {
    set in  [makeFile {
        set ba [binary format c* {1 2 3}]
        return [binary encode hex $ba]
    } test_literal9-in.tcl]
    set out [makeFile "" test_literal.10-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 010203

cleanupTests

# --- AuxData kinds ----------------------------------------------------------

test test_auxdt.1 {AUX: JumpTable (string switch)} -body {
    set in  [makeFile {
        set x alpha
        switch -exact -- $x {
            alpha {set r a}
            beta  {set r b}
            default {set r d}
        }
        return $r
    } test_auxdt.1-in.tcl]
    set out [makeFile "" test_auxdt.1-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result a

test test_auxdt.2 {AUX: JumpTable (numeric switch)} -body {
    set in  [makeFile {
        set x 2
        switch -exact -- $x {
            1  {set r 11}
            2  {set r 22}
            default {set r 33}
        }
        return $r
    } test_auxdt.2-in.tcl]
    set out [makeFile "" test_auxdt.2-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 22

test test_auxdt.3 {AUX: DictUpdateInfo} -body {
    set in  [makeFile {
        set d [dict create a 1 b 2]
        dict update d a av b bv {
            set av 10
            set bv 20
        }
        return [list $d $av $bv]
    } test_auxdt.3-in.tcl]
    set out [makeFile "" test_auxdt.3-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result {{a 10 b 20} 10 20}

test test_auxdt.4 {AUX: ForeachInfo (multiple lists)} -body {
    set in  [makeFile {
        set sum 0
        foreach i {1 2} j {3 4} {
            incr sum $i
            incr sum $j
        }
        return $sum
    } test_auxdt.4-in.tcl]
    set out [makeFile "" test_auxdt.4-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 10

cleanupTests

# --- Flat script ----------------------------------------------

test test_flat.1 {FLAT: flat script} -body {
    set in  [makeFile {
        set ::a a
    } test_flat.1-in.tcl]
    set out [makeFile "" test_flat.1-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
    set ::a
} -result a

# --- Procs & Namespace bodies ----------------------------------------------

test test_proc.1 {PROC: static proc} -body {
    set in  [makeFile {
        proc up {s} {string toupper $s}
        return [up hello]
    } test_proc.1-in.tcl]
    set out [makeFile "" test_proc.1-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result HELLO

test test_proc.2 {PROC: dynamic proc (name/args/body at runtime)} -body {
    set in  [makeFile {
        set cname dyn2
        set cargs {x}
        set cbody {format "dyn2:%s" $x}
        proc $cname $cargs $cbody
        return [$cname 5]
    } test_proc.2-in.tcl]
    set out [makeFile "" test_proc.2-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result {dyn2:5}

test test_proc.3 {NAMESPACE BODY: namespace eval body compiled + executed} -body {
    set in  [makeFile {
        namespace eval N {
            proc nsproc {x} {format "ns:%s" $x}
        }
        return [N::nsproc hi]
    } test_proc.3-in.tcl]
    set out [makeFile "" test_proc.3-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result {ns:hi}

cleanupTests

# --- OO: classes, methods, ctor/dtor, superclass ---------------------------

test test_oo.1 {OO: class with method in body} -body {
    set in  [makeFile {
        oo::class create C {
            method add {a b} {expr {$a + $b}}
        }
        set o [C new]
        set r [$o add 2 3]
        $o destroy
        return $r
    } test_oo.1-in.tcl]
    set out [makeFile "" test_oo.1-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 5

test test_oo.2 {OO: method added via oo::define} -body {
    set in  [makeFile {
        oo::class create D {}
        oo::define D method mul {a b} {expr {$a * $b}}
        set o [D new]
        set r [$o mul 3 4]
        $o destroy
        return $r
    } test_oo.2-in.tcl]
    set out [makeFile "" test_oo.2-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 12

test test_oo.3 {OO: constructor runs} -body {
    set in  [makeFile {
        set ::ctor 0
        oo::class create E {
            constructor {x} { set ::ctor $x }
        }
        set o [E new 7]
        $o destroy
        return $::ctor
    } test_oo.3-in.tcl]
    set out [makeFile "" test_oo.3-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 7

test test_oo.4 {OO: destructor runs} -body {
    set in  [makeFile {
        set ::dtor 0
        oo::class create F {
            destructor { set ::dtor 1 }
        }
        set o [F new]
        $o destroy
        return $::dtor
    } test_oo.4-in.tcl]
    set out [makeFile "" test_oo.4-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 1

test test_oo.5 {OO: superclass recorded and restored} -body {
    set in  [makeFile {
        oo::class create P {}
        oo::class create Q {}
        oo::define Q superclass P
        return [lindex [info class superclasses Q] 0]
    } test_oo.5-in.tcl]
    set out [makeFile "" test_oo.5-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result ::P

cleanupTests

# --- Lambdas ---------------------------------------------------------------

test test_lambda.1 {LAMBDA: apply} -body {
    set in  [makeFile {return [apply {x} {expr {$x * 3}} 14]} test_lambda..1-in.tcl]
    set out [makeFile "" test_lambda.1-out.tbcx]
    tbcx::savefile $in $out
    tbcx::loadfile $out
} -result 42

# --- Multi-interp

# --- Multi-thread

# --- Multi-interp & multi-thread

cleanupTests
