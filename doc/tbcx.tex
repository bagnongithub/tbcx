\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{enumitem}

\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{0.6em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{0.6em}{}

\title{\LARGE TBCX for Tcl 9.1:\\ Design, Format, and Implementation Notes}
\author{TBCX Project}
\date{September 2025}

\lstdefinelanguage{Tcl}{
  morekeywords={proc,namespace,eval,oo::class,oo::define,apply,expr,return,set},
  sensitive=true,
  morecomment=[l]{\#},
  morestring=[b]{"}
}
\lstset{basicstyle=\ttfamily\small,columns=fullflexible,showstringspaces=false}

\begin{document}
\maketitle

\begin{abstract}
This document describes the TBCX (Tcl ByteCode eXchange) file format and the
accompanying \texttt{tbcx} extension for Tcl~9.1. TBCX allows precompiling Tcl
scripts to a compact, portable, little-endian binary representation that can be
loaded later without recompilation. We cover the public API, the exact on-disk
format, loader behavior, and implementation details relevant to embedding and tooling.
\end{abstract}

\section{Overview and Goals}
TBCX goals:
\begin{itemize}[nosep]
  \item \textbf{Zero source recompilation at load time}: ship precompiled bodies.
  \item \textbf{Portability}: files are little-endian and validated at load.
  \item \textbf{Determinism}: dictionaries and jump tables are serialized in a stable order.
  \item \textbf{Safety}: only supported AuxData kinds are encoded; inputs are size-checked.
\end{itemize}

The package provides \texttt{tbcx::save}, \texttt{tbcx::savechan}, \texttt{tbcx::savefile},
\texttt{tbcx::loadchan}, \texttt{tbcx::loadfile}, and \texttt{tbcx::dumpfile}. The package
version is \texttt{1.0}.

\section{Public API}
\subsection{Saving}
\begin{description}[style=nextline]
  \item[\texttt{tbcx::save \emph{script} \emph{outPath}}] Compile \emph{script} and write a TBCX file.
  \item[\texttt{tbcx::savechan \emph{script} \emph{channelName}}] Compile and write to an open channel; the command configures the channel for binary I/O.
  \item[\texttt{tbcx::savefile \emph{in.tcl} \emph{outPath}}] Read \emph{in.tcl}, compile, and write a TBCX file.
\end{description}
\subsection{Loading and Inspecting}
\begin{description}[style=nextline]
  \item[\texttt{tbcx::loadfile \emph{in.tbcx}}] Load and evaluate a TBCX file in the current namespace.
  \item[\texttt{tbcx::loadchan \emph{channelName}}] Load and evaluate from a channel (configured for binary).
  \item[\texttt{tbcx::dumpfile \emph{filename}}] Return a text dump (header, sections, disassembly) for inspection.
\end{description}

\section{Stream Header}
All integers are little-endian. The header layout is:
\begin{verbatim}
struct TbcxHeader {
    u32 magic;       // "TBCX" = 0x58434254
    u32 format;      // 9
    u32 tcl_version; // maj<<24 | min<<16 | patch<<8 | type
    u64 codeLenTop;
    u32 numCmdsTop;    // always 0 in this version
    u32 numExceptTop;
    u32 numLitsTop;
    u32 numAuxTop;
    u32 numLocalsTop;
    u32 maxStackTop;
};
\end{verbatim}
The loader validates \emph{magic} and \emph{format} before continuing.

\section{Compiled Block Encoding}
A compiled block serializes one \texttt{ByteCode} object in five parts:
\begin{enumerate}[nosep]
  \item \textbf{Code}: \texttt{u32} byte length, then raw code bytes.
  \item \textbf{Literals}: \texttt{u32} count, then tagged literals (Section~\ref{sec:literals}).
  \item \textbf{AuxData}: \texttt{u32} count, then tagged AuxData (Section~\ref{sec:aux}).
  \item \textbf{Exceptions}: \texttt{u32} count, then range table (fields as \texttt{u32}).
  \item \textbf{Epilogue}: \texttt{u32} maxStack, \texttt{u32} reserved (0), \texttt{u32} numLocals.
\end{enumerate}
For top-level compilation the default namespace is the current one at load time. For nested
\texttt{lambdaExpr} and \texttt{bytecode} literals the stream precedes the block with a namespace FQN
(LPString) and ensures that namespace exists before instantiation.

\subsection{Limits}
Enforced maxima: code $\leq$ 1\,GiB; literals $\leq$ 64\,M; AuxData $\leq$ 64\,M; exceptions $\leq$ 64\,M;
any LPString $\leq$ 16\,MiB.

\section{Literals}
\label{sec:literals}
Each literal begins with a \texttt{u32} tag:
\begin{center}
\begin{tabular}{ll}
  0 & \textbf{BIGNUM}: \texttt{u8} sign (0=zero, 1=+, 2=--), \texttt{u32} magLen, then \texttt{magLen} LE bytes. \\
  1 & \textbf{BOOLEAN}: \texttt{u8} (0/1). \\
  2 & \textbf{BYTEARR}: \texttt{u32} length + bytes. \\
  3 & \textbf{DICT}: \texttt{u32} pair count, then key literal + value literal (keys sorted by UTF-8). \\
  4 & \textbf{DOUBLE}: 64-bit IEEE-754 as \texttt{u64}. \\
  5 & \textbf{LIST}: \texttt{u32} element count, then that many nested literals. \\
  6 & \textbf{STRING}: LPString (\texttt{u32} length + bytes). \\
  7 & \textbf{WIDEINT}: signed 64-bit two's complement (\texttt{u64} payload). \\
  8 & \textbf{WIDEUINT}: unsigned 64-bit integer (promoted to bignum by loader if needed). \\
  9 & \textbf{LAMBDA\_BC}: ns FQN (LPString), \texttt{u32} \emph{numArgs}; for each arg: name (LPString), \texttt{u8} hasDefault, optional default literal; then compiled block. \\
  10 & \textbf{BYTECODE}: ns FQN (LPString) + compiled block. \\
\end{tabular}
\end{center}

\paragraph{Lambda bodies.} For \textbf{LAMBDA\_BC} the saver marshals the public \emph{args} list and
compiles the body using proc semantics, creating a temporary \texttt{Proc} whose argument locals match
the lambda signature.

\section{AuxData}
\label{sec:aux}
Supported AuxData tags:
\begin{description}[style=nextline]
  \item[JT\_STR (0)] \texttt{u32} count; for each entry: LPString key, \texttt{u32} target offset.
  \item[JT\_NUM (1)] \texttt{u32} count; for each entry: \texttt{u64} key, \texttt{u32} target offset.
  \item[DICT\_UPDATE (2)] \texttt{u32} length; then that many local indices.
  \item[NEW\_FOREACH (3), FOREACH (4)] \texttt{u32} numLists, \texttt{u32} loopCtTemp, \texttt{u32} firstValueTemp, duplicate \texttt{numLists}; for each list: \texttt{u32} numVars, then indices.
\end{description}
The loader maps either FOREACH tag to the closest available core AuxData type.

\section{Procedures, Classes, and Methods}
\subsection{Static capture and sections}
The saver parses the source text to capture static definitions:
\texttt{proc name args body}, \texttt{namespace eval \emph{ns} body},
and \texttt{oo::define} forms for methods/ctors/dtors, plus \texttt{oo::class create}.
For each captured proc it stores three LPStrings (name as written, ns FQN, and the canonical args list)
followed by the compiled body. Classes are written with their FQN and a list of superclasses (0 for now).
Methods are written with class FQN, kind (inst/class/ctor/dtor), optional name, args list, and compiled body.

\subsection{Load-time reconstruction}
The loader installs temporary shims:
\begin{itemize}[nosep]
  \item \textbf{proc shim}: on \texttt{proc name args body}, if the fully-qualified name and \emph{args}
        match an entry from the file, substitute the precompiled body; otherwise forward unchanged.
  \item \textbf{oo::define shim}: for \texttt{method}, \texttt{classmethod}, \texttt{constructor},
        and \texttt{destructor}, substitute the precompiled body when the \emph{args} list matches.
\end{itemize}
After reading all sections the loader evaluates the top-level block (with the current namespace as default),
then restores the original commands and discards the shims.

\subsection{Locals and variable frames}
For each compiled body the saver records \texttt{numLocals}. The loader extends the \texttt{Proc}'s compiled-local
list to at least that length to keep Tcl's invariants when freeing or redefining the proc later.

\section{Disassembly Tool}
The command \texttt{tbcx::dumpfile} produces a readable dump: header, compiled-block structure,
AuxData, exceptions, and a disassembly. The decoder table is aligned to Tcl~9.1's
\texttt{tclInstructionTable}. Opcodes marked ``deprecated'' correspond to legacy one-byte forms and may
still be shown to aid debugging.

\section{Portability and Limits}
Streams are little-endian; both writer and reader swap on big-endian hosts. Size limits at save and load
prevent pathological inputs (1\,GiB code; pools up to 64\,M elements; LPString up to 16\,MiB).

\section{Examples}
\subsection{Proc and class}
\begin{lstlisting}[language=Tcl]
set s {
  proc add {a b} { expr {$a + $b} }
  oo::class create C
  oo::define C method m {x} { expr {$x * 2} }
}
tbcx::save $s out.tbcx
tbcx::loadfile out.tbcx
puts [add 2 3]           ;# => 5
puts [[C new] m 10]      ;# => 20
\end{lstlisting}

\subsection{Channels}
\begin{lstlisting}[language=Tcl]
set ch [open "bundle.tbcx" w]
fconfigure $ch -translation binary -eofchar {}
tbcx::savechan {proc p {} {return ok}} $ch
close $ch

set ch [open "bundle.tbcx" r]
fconfigure $ch -translation binary -eofchar {}
tbcx::loadchan $ch
close $ch
\end{lstlisting}

\section{Build and Initialization Notes}
The extension uses Tcl's stubs and TomMath stubs. During initialization the package resolves
the necessary \texttt{Tcl\_ObjType}s (\texttt{bytecode}, \texttt{list}, \texttt{dict}, \texttt{int},
\texttt{double}, \texttt{boolean}, \texttt{bytearray}, \texttt{bignum}, and optionally
\texttt{lambdaExpr}) and the AuxData type pointers (\texttt{JumptableInfo}, \texttt{JumptableNumInfo},
\texttt{DictUpdateInfo}, \texttt{ForeachInfo}, \texttt{NewForeachInfo}).

\paragraph{Endianness.} Endianness is detected once (via \texttt{tcl\_platform(byteOrder)} or a probe) and
cached; streams are always written and read as little-endian.

\section*{Acknowledgments}

Thanks to the Tcl core for public/internal APIs enabling safe precompilation and to the reviewers who improved the serializer/loader design.

\section{License}
MIT License. Copyright \copyright{} 2025 Miguel Bañón.

\end{document}
