\" -*- nroff -*-
'\"
'\" tbcx(n) -- Save, load, dump, and execute Tcl bytecode files (Tcl 9.1+ extension)
'\"
.TH tbcx n "September 2025" "tbcx 1.0" "Tcl Extensions"
.SH NAME
tbcx \- save, load, and inspect precompiled Tcl bytecode streams (.tbcx) for Tcl 9.1+
.SH SYNOPSIS
.nf
package require tbcx 1.0
.fi
.PP
.nf
tbcx::save      \fIscript outPath\fR
tbcx::savechan  \fIscript channelName\fR
tbcx::savefile  \fIin.tcl outPath\fR
tbcx::loadchan  \fIchannelName\fR
tbcx::loadfile  \fIin.tbcx\fR
tbcx::dumpfile  \fIfilename\fR
.fi
.SH DESCRIPTION
The \fBtbcx\fR package serializes and restores Tcl 9.1 bytecode in a
portable stream format (\fB.tbcx\fR).  It lets you precompile Tcl code and
ship the resulting bytecode, avoiding compilation at runtime.
.PP
The format is intentionally simple and little\-endian so streams produced
on any host can be consumed on any other.  The loader recreates top\-level
bytecode, procedure bodies, and TclOO methods, and evaluates the top\-level
block to install definitions into the caller's interpreter.
.SH COMMANDS
.SS tbcx::save \fIscript outPath\fR
Compile \fIscript\fR and write a .tbcx stream to \fIoutPath\fR. On success the
result is the normalized output path.
.PP
Errors come from compilation or I/O; the command fails with a diagnostic.
.PP
.SS tbcx::savechan \fIscript channelName\fR
Compile \fIscript\fR and write the .tbcx stream to an already opened Tcl
channel named \fIchannelName\fR. The channel is switched to binary mode.
.PP
.SS tbcx::savefile \fIin.tcl outPath\fR
Read \fIin.tcl\fR as a binary file, compile its content, and write a .tbcx
stream to \fIoutPath\fR. On success the result is the normalized output path.
.PP
.SS tbcx::loadchan \fIchannelName\fR
Read a .tbcx stream from the open binary \fIchannelName\fR and load it into
the current interpreter. The top\-level code is evaluated with
\fBTCL_EVAL_GLOBAL\fR after precompiled procedures and methods are registered.
.PP
.SS tbcx::loadfile \fIin.tbcx\fR
Open \fIin.tbcx\fR and behave like \fBtbcx::loadchan\fR.
.PP
.SS tbcx::dumpfile \fIfilename\fR
Open and decode \fIfilename\fR and print a human\-readable dump of the stream,
including header fields, literal pool, AuxData, disassembled bytecode, and
exception ranges.
.SH STREAM FORMAT (OVERVIEW)
A .tbcx file contains:
.IP \(bu 2
A fixed header.
.IP \(bu 2
One compiled block for the top level.
.IP \(bu 2
A procs section.
.IP \(bu 2
A classes section.
.IP \(bu 2
A methods section.
.PP
A compiled block is encoded as:
.RS
.IP "1." 3
Code bytes length (\fBu32LE\fR) then raw code bytes.
.IP "2." 3
Literal pool count (\fBu32LE\fR) then that many literals.
.IP "3." 3
AuxData array count (\fBu32LE\fR) then that many AuxData items.
.IP "4." 3
Exception range count (\fBu32LE\fR) then that many ranges.
.IP "5." 3
Epilogue: \fBmaxStack\fR (\fBu32LE\fR), \fBreserved\fR (\fBu32LE\fR, zero),
\fBnumLocals\fR (\fBu32LE\fR).
.RE
.SS Header
All multi\-byte numbers are little\-endian. The header layout is:
.PP
.nf
u32 magic       = 0x58434254  ("TBCX")
u32 format      = 9
u32 tcl_version = PackTclVersion()  ; mmjjppTT
u64 codeLenTop
u32 numCmdsTop      ; 0 in this implementation
u32 numExceptTop
u32 numLitsTop
u32 numAuxTop
u32 numLocalsTop
u32 maxStackTop
.fi
.PP
The saver writes these from the compiled top\-level block.
.SS Limits
To guard against malformed inputs:
.PP
.nf
codeLen   <= 1 GiB
literals  <= 64 M
auxData   <= 64 M
exceptions<= 64 M
LPString  <= 16 MiB
.fi
.SS Literals
Each literal is a \fBu32LE\fR tag followed by a tag\-specific payload:
.PP
.nf
0  BIGNUM     : u8 sign(0,1,2) + u32 n + n bytes (magnitude, little\-endian)
1  BOOLEAN    : u8 (0/1)
2  BYTEARR    : u32 n + n bytes
3  DICT       : u32 count + count × {keyLit, valLit}
4  DOUBLE     : u64 raw IEEE\-754 bits (host written & byteswapped as LE)
5  LIST       : u32 n + n × literal
6  STRING     : LPString (u32 len + bytes, no NUL)
7  WIDEINT    : u64 two's complement
8  WIDEUINT   : u64 (promoted to bignum if out of Tcl wide range)
9  LAMBDA_BC  : LPString nsFQN, u32 argc,
                argc × {LPString name, u8 hasDefault, [default literal]},
                then a compiled block for the body
10 BYTECODE   : LPString nsFQN, then a compiled block
.fi
.SS AuxData
The AuxData array mirrors Tcl's internal aux records for certain opcodes.
Supported tags:
.PP
.nf
0  JT_STR     : u32 cnt + cnt × {LPString key, u32 targetOffset}
1  JT_NUM     : u32 cnt + cnt × {u64 key, u32 targetOffset}
2  DICTUPD    : u32 L + L × u32 varIndex
3  NEWFORE    : foreach(new) record (see below)
4  FOREACH    : foreach(old) record (see below)
.fi
.PP
Foreach records encode:
.RS
.IP \(bu 2
\fInumLists\fR, \fIloopCtTemp\fR, \fIfirstValueTemp\fR, and a duplicate
\fInumLists\fR (sanity check).
.IP \(bu 2
For each list: \fInumVars\fR then that many local variable indices.
.IP \(bu 2
The loader maps both tags to the appropriate runtime aux type
(\fBForeachInfo\fR or \fBNewForeachInfo\fR), preferring the name that matches
the tag and falling back when necessary.
.RE
.SS Exception ranges
Each range is encoded as seven \fBu32LE\fR values: \fBtype\fR (low 8 bits
used), \fBnestingLevel\fR, \fBcodeOffset\fR, \fBnumCodeBytes\fR,
\fBcontinueOffset\fR, \fBbreakOffset\fR, \fBcatchOffset\fR.
.SS Procs section
Count (\fBu32LE\fR) then that many entries, each:
.RS
.IP \(bu 2
LPString \fIprocName\fR (as provided) and LPString \fIns\fR (namespace FQN).
.IP \(bu 2
LPString \fIargs\fR (canonical list).
.IP \(bu 2
A compiled block for the body (compiled with \fBproc\fR semantics under
\fIns\fR). The epilogue's \fBnumLocals\fR is the max of the local cache size
(if present) and what can be inferred from AuxData usage.
.RE
.PP
On load, \fBproc\fR is temporarily replaced by a shim that substitutes the
precompiled \fBprocbody\fR when the call defines a procedure whose FQN and
argument list exactly match the registry entry; otherwise it forwards to the
original \fBproc\fR. The shim is removed after the top\-level evaluation.
.SS Classes section
Count (\fBu32LE\fR) then that many entries, each LPString class FQN and
\fBu32\fR number of superclasses (currently 0). The saver records classes it
observes in the source; the loader ensures the namespaces exist.
.SS Methods section
Count (\fBu32LE\fR) then that many entries, each:
.RS
.IP \(bu 2
LPString \fIclassFqn\fR.
.IP \(bu 2
u8 \fIkind\fR: 0=inst, 1=class, 2=ctor, 3=dtor.
.IP \(bu 2
LPString \fIname\fR (empty for ctor/dtor).
.IP \(bu 2
LPString \fIargs\fR (canonical list), u32 \fIbodyTextLen\fR (reserved, 0),
then a compiled block for the body.
.RE
.PP
On load, \fBoo::define\fR is temporarily replaced by a shim that substitutes
the precompiled body when the method/ctor/dtor being defined in script has the
same argument list as the registry entry; otherwise it forwards to the original.
.SH ENDIANNESS
Streams are always little\-endian. The saver byteswaps on big\-endian hosts,
and the loader byteswaps while reading on big\-endian hosts. Double literals
are moved as raw 64\-bit bit patterns.
.SH EXAMPLES
.PP
Precompile a package and load it later:
.PP
.nf
set out [tbcx::save {
    namespace eval ::demo {
        proc add {a b} { expr {$a + $b} }
    }
} demo.tbcx]
# Later, possibly in another process or machine:
tbcx::loadfile $out
puts [demo::add 2 3]   ;# -> 5
.fi
.PP
Dump a file for inspection:
.PP
.nf
puts [tbcx::dumpfile demo.tbcx]
.fi
.SH DIAGNOSTICS
Typical errors include: "short read/write", "string too large", "too many
literals/aux/exception ranges", "unsupported AuxData kind", "unknown literal
tag", "bad header", and failures from the Tcl compiler.
.SH COMPATIBILITY NOTES
.IP \(bu 2
The instruction decoder used by \fBtbcx::dumpfile\fR matches Tcl 9.1. Legacy
one\-byte forms are marked as deprecated in the dump.
.IP \(bu 2
The loader installs temporary shims for \fBproc\fR and \fBoo::define\fR and
removes them after the top\-level block evaluates.
.SH SEE ALSO
Tcl(n), bytecode(n), TclOO(n), source(n), proc(n), namespace(n), oo::class(n), oo::define(n)
.SH KEYWORDS
bytecode, compile, load, save, dump, channel, packaging
.SH COPYRIGHT
MIT License

Copyright (c) 2025 Miguel Banon
